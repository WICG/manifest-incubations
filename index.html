<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Manifest Incubations
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class=
    "remove"></script>
    <script class='remove'>
      // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
      var respecConfig = {
        specStatus: "CG-DRAFT",
        editors: [{
          name: "Daniel Murphy"
        }],
        group: "wicg",
        github: "WICG/manifest-incubations",
        shortName: "manifest-incubations",
        xref: {
          specs: ["appmanifest", "dom", "mimesniff", "file-system-access"],
          profile: "web-platform",
        },
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        Feature specifications for <a href=
        "https://www.w3.org/TR/appmanifest/">Web Application Manifest</a>
        extensions & incubations which Chromium has shipped but do not have
        committments / implementations from other user agents. Instead of
        keeping these features as explainers, they are documented more
        officially here.
      </p>
    </section>
    <section id="sotd">
      <p>
        This is an unofficial proposal.
      </p>
    </section>
    <section>
      <h2 data-dfn-for="">
        <code>display_override</code> member
      </h2>
      <p>
        For advanced usages, the display_override member can be used to specify
        a custom fallback order of <a data-cite=
        "appmanifest#dfn-display-modes-values">display mode values</a> for
        developers to choose their preferred <a data-cite=
        "appmanifest#dfn-display-mode">display mode</a>.
      </p>
      <p>
        The <dfn>display_override</dfn> member of the [=application manifest=]
        is a <a>sequence</a> of <a data-cite=
        "appmanifest#dfn-display-modes-values">display mode values</a>. This
        item represents the developer's preferred fallback chain for
        <a data-cite="appmanifest#dfn-display-mode">display modes</a>. This
        field overrides the [=manifest/display=] member. If the user agent does
        not support any of the display modes specified here, then it falls back
        to considering the [=manifest/display=] member. See <a data-cite=
        "appmanifest#dfn-display-mode">display modes</a> for the algorithm
        steps.
      </p>
      <p>
        The following steps are added to the [=application manifest/processing
        extension-point=] in <a data-cite=
        "appmanifest#dfn-steps-for-determining-the-web-app-s-chosen-display-mode">
        determining the web app's chosen display mode</a>:
      </p>
      <ol>
        <li>[=list/For each=] |candidate_display_mode:DisplayModeType| of
        |manifest|.{{display_override}}:
          <ol>
            <li>If the user agent supports the |candidate_display_mode|, then
            return |candidate_display_mode|.
            </li>
          </ol>
        </li>
      </ol>
      <p class="note">
        This member is intended to be only used for advanced cases, where the
        developer wants explicit control over the fallback order of their
        display modes. Otherwise, the [=manifest/display=] member is sufficient
        for most use cases.
      </p>
      <section class="informative">
        <h3>
          Usage Example
        </h3>
        <p>
          The following shows a [=manifest=] that prefers the
          <code>minimal-ui</code> <a data-cite=
          "appmanifest#dfn-display-mode">display mode</a> over
          <code>standalone</code>, but if <code>minimal-ui</code> isn't
          supported, falls back to <code>standalone</code> as opposed to
          <code>browser</code>.
        </p>
        <pre class="example json" title="Advanced display usage manifest">
          {
            "name": "Recipe Zone",
            "description": "All of the recipes!",
            "icons": [{
              "src": "icon/hd_hi",
              "sizes": "128x128"
            }],
            "start_url": "/index.html",
            "display_override": ["minimal-ui"],
            "display": "standalone",
            "theme_color": "yellow",
            "background_color": "red"
          }
        </pre>
      </section>
    </section>
    <section>
      <h2>
        `share_target` member
      </h2>
      <p>
        The `share_target` member registers a web application as "target" for
        share actions (e.g., for sharing a text, a URL, or a file). The
        `share_target` member is part of the [[[web-share-target]]]
        specification.
      </p>
    </section>
    <section>
      <h2>
        <code><dfn>note_taking</dfn></code> member
      </h2>
      <p>
        The `note_taking` member of the <a data-cite=
        "appmanifest#web-application-manifest">Web Application Manifest</a> is
        an <a data-cite="appmanifest#dfn-object">object</a> that contains
        information related to note-taking. It has the following members:
      </p>
      <ul>
        <li>[=note_taking/new_note_url=]
        </li>
      </ul>
      <p>
        A user agent MAY use these members to treat the web application
        differently as an application with note-taking capabilities (e.g.,
        integrate with operating system note-taking surfaces).
      </p>
      <section>
        <h3>
          <code><dfn data-dfn-for="note_taking">new_note_url</dfn></code>
          member
        </h3>
        <p>
          The [=note_taking=] `new_note_url` member is a [=string=] that
          represents the <a data-cite="url#concept-url">URL</a> the developer
          would prefer the user agent load when the user wants to take a new
          note using the web application (e.g., from an operating system
          shortcut icon or keyboard shortcut).
        </p>
        <p>
          The `new_note_url` member is purely advisory, and a user agent MAY
          <a data-cite="appmanifest#dfn-ignore">ignore</a> it or provide the
          end-user the choice of whether to use it. The user agent MAY provide
          the end-user the choice to modify it.
        </p>
        <aside class="note">
          <p>
            The `new_note_url` member is parsed with <a data-cite=
            "appmanifest#dfn-manifest-url">manifest URL</a> as the base URL and
            is ignored if not [=manifest/within scope=] of the manifest.
          </p>
        </aside>
      </section>
      <section class="informative">
        <h3>
          Usage Example
        </h3>
        <p>
          The following shows a [=manifest=] for a note-taking application.
        </p>
        <pre class="example json" title="Note-taking application">
          {
            "name": "My Note Taking App",
            "description": "You can take notes!",
            "icons": [{
              "src": "icon/hd_hi",
              "sizes": "128x128"
            }],
            "start_url": "/index.html",
            "display": "standalone",
            "note_taking": {
              "new_note_url": "/new_note.html"
            }
          }
        </pre>
      </section>
      <section>
        <h3>
          Processing the `note_taking` member
        </h3>
        <p>
          To <dfn>process the `note_taking` member</dfn>, given [=ordered map=]
          |json:ordered map|, [=ordered map=] |manifest:ordered map|, [=URL=]
          |manifest_URL:URL|, run the following during the <a data-cite=
          "appmanifest#dfn-processing-extension-point-of-web-manifest">extension
          point</a> in [=processing a manifest=]:
        </p>
        <ol class="algorithm">
          <li>If |json|["note_taking"] does not [=map/exist=], return.
          </li>
          <li>If the type of |json|["note_taking"] is not [=ordered map=],
          return.
          </li>
          <li>Set |manifest|["note_taking"] to a new [=ordered map=].
          </li>
          <li>[=process the `new_note_url` member=] passing
          |json|["note_taking"], |manifest|["note_taking"], and |manifest URL|.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Processing the `new_note_url` member
        </h3>
        <p>
          To <dfn>process the `new_note_url` member</dfn>, given [=ordered
          map=] |json_note_taking:ordered map|, [=ordered map=]
          |manifest_note_taking:ordered map|, [=URL=] |manifest_URL:URL|, run
          the following:
        </p>
        <ol class="algorithm">
          <li>If |json_note_taking|["new_note_url"] does not [=map/exist=],
          return.
          </li>
          <li>If the type of |json_note_taking|["new_note_url"] is not
          [=string=], return.
          </li>
          <li>Let |new_note_url:URL| be the result of [=URL Parser|parsing=]
          |json_note_taking|["new_note_url"] with |manifest URL| as the base
          URL.
          </li>
          <li>If |new_note_url| is failure, return.
          </li>
          <li>If |new_note_url| is not [=manifest/within scope=] of |manifest
          URL|, return.
          </li>
          <li>Set manifest_note_taking["new_note_url"] to |new_note_url|.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Launching the `new_note_url`
        </h3>
        <p>
          To <dfn>launch the `new_note_url`</dfn>, given <a data-cite=
          "appmanifest#dfn-processed-manifest">processed manifest</a>
          |manifest:processed manifest|, run the following steps:
        </p>
        <ol>
          <li>If |manifest|["note_taking"] does not [=map/exist=], return.
          </li>
          <li>If |manifest|["note_taking"]["new_note_url"] does not
          [=map/exist=], return.
          </li>
          <li>If the type of |manifest|["note_taking"]["new_note_url"] is not
          [=URL=], return.
          </li>
          <li>Let |browsing context:Browsing Context| be the result of creating
          a new [=top-level browsing context=].
          </li>
          <li>[=Navigate=] |browsing context| to resource
          |manifest|["note_taking"]["new_note_url"].
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>
        `protocol_handlers` member
      </h2>
      <p>
        The [=manifest's=] <code><dfn data-dfn-for=
        "manifest">protocol_handlers</dfn></code> member is an array of
        <a>protocol handler description</a>s that allows a web application to
        handle URL protocols.
      </p>
      <p>
        On installation, a user agent SHOULD register protocol handlers with
        the Operating System via interactions that are consistent with:
      </p>
      <ul>
        <li>If there are multiple registered handlers for a protocol, the OS
        allows the user to select which app should open it, and also allows the
        user to set a default app.
        </li>
        <li>Clicking on a registered protocol will launch the registered
        application. If this is the web app, then execute the [=invoke a
        protocol handler=] steps defined in [=HTML=], where the user agent
        SHOULD navigate to [=url=] and the appropriate browsing context is set
        to a new top level browsing context.
        </li>
      </ul>
      <aside class="note">
        Protocol handlers could, for instance, be used for web app
        communication where one app directly invokes another and passes data
        via custom protocol links.
      </aside>
      <section>
        <h3>
          Processing the `protocol_handlers` member
        </h3>
        <p>
          To <dfn>process the `protocol_handlers` member</dfn>, given
          [=object=] |json:JSON|, |manifest:ordered map|:
        </p>
        <ol>
          <li>Let |processedProtocolHandlers| be a new [=list=] of
          |json:JSON|["|protocol_handlers|"].
          </li>
          <li>Set manifest["|protocol_handlers|"] to
          |processedProtocolHandlers|.
          </li>
          <li>[=list/For each=] |protocol_handler| (<a>protocol handler
          description</a>):
            <ol>
              <li>If |protocol_handler|["protocol"] or
              |protocol_handler|["url"] is undefined, [=iteration/continue=].
              </li>
              <li>Let (<dfn>normalizedProtocol</dfn>, <dfn>normalizedUrl</dfn>)
              be the result of running [=normalize protocol handler
              parameters=] with |protocol_handler|["protocol"], |
              protocol_handler|["url"] using |manifest URL| as the base URL,
              and [=this=]'s relevant [=environment settings object=]. If the
              result is failure, [=iteration/continue=].
              </li>
              <li>If [=normalizedUrl=] is not [=manifest/within scope=] of
              |manifest|, [=iteration/continue=].
              </li>
              <li>If |processedProtocolHandlers| [=list/contains=] the
              [=normalizedUrl=], [=iteration/continue=].
              </li>
              <li>[=List/Append=] |protocol_handler| to
              |processedProtocolHandlers|.
              </li>
            </ol>
          </li>
          <li>[=list/For each=] |processedProtocolHandlers|, the user agent
          SHOULD [=register a protocol handler=].
          </li>
        </ol>
        <p>
          A user agent SHOULD ask users for permission before registering a
          [=protocol handler description=] <var>protocol_handler</var>s as the
          default handler for a protocol with the host operating system. A user
          agent MAY truncate the list of [=protocol handler description=]
          <var>protocol_handlers</var> presented in order to remain consistent
          with the conventions or limitations of the host operating system.
        </p>
        <aside class="example">
          <p>
            In the following example, the developer has included two [=protocol
            handler description=] <var>protocol_handler</var>s. Assuming the
            the manifest's URL is
            <samp>https://example.com/manifest.webmanifest</samp>:
          </p>
          <ul>
            <li>The first protocol handler would register to handle "web+music"
            URLs (e.g.: web+music://#1234). When activated, the user agent
            would instantiate a new[=top-level browsing context=] and navigate
            to
            <samp>https://example.com/play?songId=web+music://%231234</samp>.
            </li>
            <li>The second protocol handler would be ignored, as the protocol
            provided does not start with "web+" and is not part of the
            [=safelisted schemes=].
            </li>
          </ul>
          <pre class="json">
            {
              "protocol_handlers": [
                {
                  "protocol": "web+music",
                  "url": "/play?songId=%s"
                },
                {
                  "protocol": "store",
                  "url": "/buy?songId=%s"
                }
              ]
            }
          </pre>
        </aside>
      </section>
      <section>
        <h2>
          ProtocolHandler items
        </h2>
        <p>
          Each <dfn>protocol handler description</dfn> is an [=object=] that
          represents a protocol that the web application wants to handle. It
          has the following members:
        </p>
        <ul>
          <li>[=`protocol`=]
          </li>
          <li>[=`url`=]
          </li>
        </ul>
        <p>
          A user agent SHOULD use these values to register the web application
          as a handler with the operating system. When the user activates a
          protocol handler URL, the user agent SHOULD run <a>handling a
          protocol launch</a>.
        </p>
        <p class="note">
          [[HTML]]'s {{NavigatorContentUtils/registerProtocolHandler()}} allows
          web sites to register themselves as possible handlers for particular
          protocols. What constitutes valid <code>protocol</code> and
          <code>url</code> values for <a>protocol handler description</a>s is
          defined in that API. Also note that the [[HTML]] API uses
          [=url/scheme=] where we use <code>protocol</code> but the same
          restrictions apply.
        </p>
        <section>
          <h3>
            `protocol` member
          </h3>
          <p>
            The <dfn>protocol</dfn> member of a <a>protocol handler
            description</a> is a <a>string</a> that represents the protocol to
            be handled, such as `mailto` or `web+auth`.
          </p>
          <p>
            The <a>protocol</a> member of a <a>protocol handler description</a>
            is equivalent to
            {{NavigatorContentUtils/registerProtocolHandler()}}'s |scheme|
            argument defined in [[HTML]].
          </p>
        </section>
        <section>
          <h3>
            `url` member
          </h3>
          <p>
            The <dfn>url</dfn> member of a <a>protocol handler description</a>
            is the <a>URL</a> [=manifest/within scope=] of the application that
            opens when the associated protocol is activated.
          </p>
          <p>
            The <a>url</a> member of a <a>protocol handler description</a> is
            equivalent to {{NavigatorContentUtils/registerProtocolHandler()}}'s
            <code>url</code> argument defined in [[HTML]].
          </p>
        </section>
        <section>
          <h3>
            <dfn>Handling a protocol launch</dfn>
          </h3>
          <p>
            When a <a>protocol handler description</a>
            <var>protocol_handler</var> having [=manifest=] <var>manifest</var>
            is invoked, it goes through the same steps used to [=invoke a
            protocol handler=] defined in [=HTML=], where the user agent SHOULD
            navigate to [=url=] and the appropriate browsing context is set to
            a new top level browsing context.
          </p>
        </section>
      </section>
      <section>
        <h2>
          Privacy consideration: Default protocol handler
        </h2>
        <p>
          Depending on the operating system capabilities, the protocol handler
          could become a 'default' handler (e.g. handling launches of a given
          protocol automatically) of a given protocol without the explicit
          knowledge of the user. To protect against possible misuse, user
          agents MAY employ protections such as:
        </p>
        <ul>
          <li>Requiring explicit user consent before executing the process to
          [=invoke a protocol handler=].
          </li>
          <li>Removing the web application's OS registration as a protocol
          handling entity, either in response to the above dialog or by user
          action.
          </li>
          <li>Confirming protocol handler registrations on [=installation=].
          </li>
        </ul>
        <p>
          If a user agent removes the the registration of the protocol handler
          entity it SHOULD provide UX for the user to re-register the web app
          and protocol with the operating system.
        </p>
      </section>
    </section>
    <section>
      <h3>
        `file_handlers` member
      </h3>
      <p>
        The [=manifest's=] <code><dfn data-export="" data-dfn-for=
        "manifest">file_handlers</dfn></code> member is a [=list=] that
        provides instructions for how the app handles file-opening actions that
        originate outside of the app itself.
      </p>
      <p>
        The management, presentation, and selection of registered file-handling
        applications is at the discretion of the operating system.
      </p>
      <p>
        To <dfn class="lint-ignore">process the `file_handlers` member</dfn>,
        given [=ordered map=] |json:ordered map|, [=ordered map=]
        |manifest:ordered map|, [=URL=] |manifest_url:URL|:
      </p>
      <ol class="algorithm">
        <li>Let |processedFileHandlers:list| be a new [=list=].
        </li>
        <li>Set |manifest|["file_handlers"] to |processedFileHandlers|.
        </li>
        <li>If |json|["file_handlers"] doesn't [=map/exist=] or
        |json|["file_handlers"] is not a [=list=], return.
        </li>
        <li>[=list/For each=] |entry:ordered map| of |json|["file_handlers"]:
          <ol>
            <li>Let |file_handler:ordered map| be [=process a file handler
            item=] with |entry|, [=manifest/start_url=], [=manifest/scope=],
            and |manifest_url|.
            </li>
            <li>If |file_handler| is failure, continue.
            </li>
            <li>[=list/Append=] |file_handler| to |processedFileHandlers|.
            </li>
          </ol>
        </li>
      </ol>
      <p>
        On [=installation=], a user agent SHOULD run the process to [=register
        file handlers=].
      </p>
      <section data-cite="file-system-access">
        <h2>
          File Handler Items
        </h2>
        <p>
          Each <dfn data-local-lt="file handler">file handler</dfn> represents
          a URL in the scope of the application that can handle launches with
          [=file types=] it accepts. It has the following members:
        </p>
        <ul>
          <li>[=file handler/action=]
          </li>
          <li>[=file handler/name=]
          </li>
          <li>[=file handler/accept=]
          </li>
          <li>[=file handler/icons=]
          </li>
        </ul>
        <p>
          A user agent can use these members to associate the web application
          with [=file type=] on the operating system.
        </p>
        <p>
          A <dfn>file type</dfn> can be defined by a [=mime type=] and/or
          [=file extension=]. A file belongs to a file type if the OS
          determines it to have a mime type and/or its name ends with a certain
          [=file extension=]. A <dfn>file extension</dfn> is a string that
          start with a "." and only contains [=valid suffix code points=]. A
          <dfn>valid suffix code point</dfn> is a [=code point=] that is
          [=ASCII alphanumeric=], U+002B (+), or U+002E (.). Additionally,
          [=file extensions=] are limited to a length of 16 code points.
        </p>
        <aside class="note">
          <p>
            These code points were chosen to support most pre-existing file
            formats. The vast majority of file extensions are purely
            alphanumeric, but compound extensions (such as .tar.gz) and
            extensions such as .c++ for C++ source code are also fairly common,
            hence the inclusion of + and . as allowed code points.
          </p>
        </aside>
        <section>
          <h3>
            `action` member
          </h3>
          <p>
            The [=file handler=]'s <code><dfn data-dfn-for=
            "file handler">action</dfn></code> member is a <a>string</a> that
            represents a URL relative to the <a data-cite=
            "appmanifest#dfn-manifest-url">manifest URL</a> that is
            [=manifest/within scope=] of a <a data-cite=
            "appmanifest#dfn-processed-manifest">processed manifest</a> . This
            URL will be navigated to in the steps to [=execute a file handler
            launch=].
          </p>
        </section>
        <section>
          <h3>
            `name` member
          </h3>
          <p>
            The [=file handler=]'s <code><dfn data-dfn-for=
            "file handler">name</dfn></code> member is a <a>string</a> that
            identifies the file type to the user. User agents MAY pass this
            information to the operating system during file handler
            registration.
          </p>
          <aside class="note">
            <p>
              The [=file handler/name=] is used to identify and describe the
              file type in a human readable format, and is typically only
              displayed in OS surfaces (such as a file browser) if the web app
              has become the default handler for that file type. It's most
              useful for custom file types.
            </p>
          </aside>
        </section>
        <section>
          <h3>
            `icons` member
          </h3>
          <p>
            The <a>file handler</a>'s <code><dfn data-dfn-for=
            "file handler">icons</dfn></code> member lists images that serve as
            graphical representations of a [=file type=] on a platform. User
            agents MAY pass this information to the operating system during
            file handler registration.
          </p>
          <aside class="note">
            Semantically, the [=file handler/icons=] are used to convey the
            file type itself and also the app. As with [=file handler/name=],
            this is typically only displayed when the app has become the
            default handler for a file type.
          </aside>
        </section>
        <section>
          <h3>
            `accept` member
          </h3>
          <p>
            The [=file handler=]'s <code><dfn data-dfn-for=
            "file handler">accept</dfn></code> member is a <a>dictionary</a>
            mapping [=MIME types=] to a list of [=file extensions=].
          </p>
          <p>
            User agents MUST enforce that the [=file handler/accept=] entry
            only applies to files that have a matching extension.
          </p>
          <p>
            In order to [=register file handlers=], some operating systems
            require [=MIME types=] and some require [=file extensions=]. Thus
            the manifest MUST always provide both for each [=file
            handler/accept=] entry.
          </p>
          <p>
            In addition to complete [=MIME types=], <code>"*"</code> can be
            used as the subtype of a MIME type to match, for example, all image
            formats with <code>"image/*"</code> (that also apply to the
            provided list of [=file extensions=]).
          </p>
          <aside class="note">
            For example, on Linux both the [=mime type=] and [=file extension=]
            is used with the <code>xdg-mime</code> utility to specify that the
            web application can open files with both the mime type specified
            and the specific file extension. On Windows, only [=file
            extensions=] are used, so the [=mime types=] are ignored.
          </aside>
        </section>
        <section>
          <h3>
            `launch_type` member
          </h3>
          <p>
            The [=file handler=]'s <code><dfn data-dfn-for=
            "file handler">launch_type</dfn></code> member is a <a>string</a>
            that determines how the app is launched for files routed to this
            handler. The possible values are "single-client" and
            "multiple-clients". If not provided, it defaults to
            "single-client".
          </p>
          <p>
            When a [=file handler=] is determined to match a set of files, the
            [=file handler/launch_type=] will control whether the app is
            launched once for each file ("multiple-clients"), or one time for
            all files ("single-client"). See {{LaunchParams/files}}. The user
            agent MUST not coalesce files from different [=file handlers=] into
            a single launch event.
          </p>
          <aside class="note">
            If an app is only meant to display one file per window or tab,
            "multiple-clients" should be applied. Otherwise, one instance will
            be launched and all opened files will be passed via the
            {{LaunchParams/files}} array.
          </aside>
        </section>
      </section>
      <section>
        <h2>
          Processing file handler items
        </h2>
        <p>
          To <dfn>process a file handler item</dfn>, given [=ordered map=]
          |item:ordered map|, [=URL=] |start_url:URL|, [=URL=] |scope:URL|, and
          [=URL=] |manifest URL:URL|:
        </p>
        <ol class="algorithm">
          <li>Return failure if any of the following are true:
            <ul>
              <li>|item|["action"] doesn't [=map/exist=] or is not a
              [=string=].
              </li>
              <li>|item|["accept"] doesn't [=map/exist=].
              </li>
              <li>|item|["accept"] is not a [=dictionary=].
              </li>
              <li>|item|["accept"] [=map/is empty=].
              </li>
            </ul>
          </li>
          <li>Let |url:URL| be the result of [=URL Parser|parsing=]
          |item|["action"] with |start_url URL| as the base URL.
          </li>
          <li>If |url| is failure, return failure.
          </li>
          <li>If |url| is not [=manifest/within scope=] of |scope|, return
          failure.
          </li>
          <li>Let |launch_type:string| be a new [=string=] initialized to
          "single-client".
          </li>
          <li>If |item|["launch_type"] [=map/exists=] and is
          "multiple-clients", set |launch_type| to |item|["launch_type"].
          </li>
          <li>Let |accept:ordered map| be a new [=ordered map=].
          </li>
          <li>[=map/for each=] |mime_type_string:string| → |extensions| of
          |item|["accept"]
            <ol>
              <li>If |extensions| is not a [=list=], continue.
              </li>
              <li>If |extensions| is [=list/empty=], continue.
              </li>
              <li>If |extensions| [=list/contains=] items that are not
              [=string=]s, continue.
              </li>
              <li>If |extensions| [=list/contains=] strings that do not begin
              with the character `.`, continue.
              </li>
              <li>Let |mime_type_parsed:mime type| be the result of running the
              steps of [=parse a mime type=] on |mime_type_string|.
              </li>
              <li>If |mime_type_parsed:mime type| is failure, continue.
              </li>
              <li>If |mime_type_parsed/type| is not listed as a top-level type
              in in [[IANA-MEDIA-TYPES]], continue.
              </li>
              <li>Set |accept|[|mime_type_string|] to |extensions|.
              </li>
            </ol>
          </li>
          <li>If |accept:ordered map| is empty, return failure.
          </li>
          <li>Let |file_handler:ordered map| be |ordered map| «[ "action" →
          |url|, "name" → |item|["name"], "launch_type" → |launch_type|,
          "launch_type" "accept" → |accept| ]».
          </li>
          <li>
            <a data-cite="appmanifest#dfn-process-image-resources">Process
            image resources</a> passing |item|["icons"], |file_handler|,
            |manifest URL|, and "icons".
          </li>
          <li>Return |file_handler|.
          </li>
        </ol>
      </section>
      <section>
        <h2>
          Execute a file handler launch
        </h2>
        <p>
          The steps to <dfn>execute a file handler launch</dfn> are given by
          the following algorithm. The algorithm takes [=list=] |files:list|
          and a [=ordered map=] |manifest:ordered_map| which holds results from
          [=processing a manifest=].
        </p>
        <ol class="algorithm">
          <li>Let |file_handlers:list| be |manifest|["file_handlers"].
          </li>
          <li>If |file_handlers:list| is null, return.
          </li>
          <li>Let |launches:ordered map| be an [=ordered map=].
          </li>
          <li>[=list/for each=] |filename:string| of |files|
            <ol>
              <li>[=list/for each=] |file_handler:ordered_map| of
              |file_handlers:list|
                <ol>
                  <li>[=map/for each=] |mime_type_string:string| →
                  |extensions:list| of |file_handler|["accept"]
                    <ol>
                      <li>[=list/for each=] |extension:string| of |extensions|
                        <ol>
                          <li>If |filename| does not end in |extension|,
                          continue.
                          </li>
                          <li>If |launches|[|file_handler|] exists, append
                          |filename| to |launches|[|file_handler|].
                          </li>
                          <li>Else, set |launches|[|file_handler|] to a list
                          with the single element |filename|.
                          </li>
                          <li>Continue to next element of |files|.
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>[=map/for each=] |file_handler| → |files:list| of |launches|
            <ol>
              <li>If |file_handler|["launch_type"] is equal to
              "multiple-clients"
                <ol>
                  <li>[=list/for each=] |file| of |files|
                    <ol>
                      <li>Let |params:LaunchParams| be a new {{LaunchParams}}
                      with {{LaunchParams/files}} set to a {{FrozenArray}} with
                      a single element that is a {{FileSystemHandle}}
                      corresponding to |file|.
                      </li>
                      <li>[=launch a web app=] with |params|.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Else,
                <ol>
                  <li>Let |params:LaunchParams| be a new {{LaunchParams}} with
                  {{LaunchParams/files}} set to a {{FrozenArray}} of
                  {{FileSystemHandle}}s that correspond to the file paths named
                  by |files|.
                  </li>
                  <li>[=launch a web app=] with |params|.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Registering file handlers
        </h3>
        <p>
          A user agent SHOULD <dfn>register file handlers</dfn> with the host
          operating system, consistent with:
        </p>
        <ul>
          <li>The app is exposed in appropriate OS surfaces such as the native
          file browser and other surfaces that display lists of apps that can
          handle a given file or file type.
          </li>
          <li>The app is a candidate for becoming the system's default handler
          for associated file types.
          </li>
        </ul>
        <p>
          A user agent MAY truncate the total set of [=file extensions=] to
          preserve functionality and prevent abuse. A user agent MAY prevent
          associations with certain filetypes.
        </p>
      </section>
      <section>
        <h3>
          Privacy consideration: Default file handler.
        </h3>
        <p>
          Depending on the operating system capabilities, the [=file handler=]
          could become a 'default' handler (e.g. handling launches of a given
          file type automatically) of a given [=file type=] without the
          explicit knowledge of the user. To protect against possible mis-use,
          user agents MAY require explicit user consent to begin with the
          process to [=execute a file handler launch=]. If consent is sought,
          the user agent SHOULD allow the user to specify that the decision is
          permanent and if so specified SHOULD remove the web application's OS
          registration as a file handling entity.
        </p>
      </section>
      <section>
        <h3>
          Privacy consideration: Name and icon.
        </h3>
        <p>
          The name and icon of each file handler can be sensitive to privacy
          and security, as there isn't a specified way for the user to see and
          confirm these. Due to this, user agents MAY choose to ignore these in
          favor of alternative strings and icons or fall back on OS defaults.
        </p>
      </section>
      <section class="informative">
        <h3>
          Example manifest with file handlers
        </h3>
        <p>
          In the following example, the web application has 3 different file
          handlers.
        </p>
        <aside class="example">
          <pre class="json">
            {
              "name": "Grafr",
              "file_handlers": [
                {
                  "action": "/open-csv",
                  "accept": {
                    "text/csv": [ ".csv" ],
                    "text/plain": [ ".txt" ]
                  }
                },
                {
                  "action": "/open-svg",
                  "accept": {
                    "image/svg+xml": [ ".svg" ]
                  }
                },
                {
                  "action": "/open-grafr",
                  "name": "Grafr graph",
                  "accept": {
                    "application/vnd.grafr-graph": [
                      ".grafr", ".graf"
                    ]
                  },
                  "icons": [
                    {
                      "src": "/grafr-file.png",
                      "sizes": "144x144"
                    }
                  ]
                }
              ]
            }
          </pre>
        </aside>
      </section>
    </section>
    <section data-cite="DOM">
      <h2>
        Installation prompts
      </h2>
      <p>
        There are multiple ways that the installation process can be triggered:
      </p>
      <ul>
        <li>An end-user can <dfn data-lt="manual installation">manually</dfn>
        trigger the installation process through the user agent's
          <abbr title="User Interface">UI</abbr>, directly invoking the steps
          to <a>present an install prompt</a>.
        </li>
        <li>The installation process can occur through an <dfn>automated
        install prompt</dfn>: that is, a UI that the user agent presents to the
        user when, for instance, there are sufficient <a>installability
        signals</a> to warrant installation of the web application.
        </li>
        <li>The installation process can occur through a <dfn>site-triggered
        install prompt</dfn>: the site can programmatically request that the
        user agent present an install prompt to the user. The user agent MAY
        restrict the availability of this feature to cases where, for instance,
        there are sufficient signals to warrant [=installed web
        application|installation=] of the web application.
        </li>
      </ul>
      <p>
        In any case, the user agent MUST NOT <a>present an install prompt</a>
        if the document is not installable.
      </p>
      <p>
        The user agent MAY, at any time (only if the document is installable),
        run the <a>steps to notify that an install prompt is available</a> at
        any time, giving the site the opportunity to show a <a>site-triggered
        install prompt</a> without the user needing to interact with the user
        agent UI.
      </p>
      <p>
        To <dfn data-local-lt=
        "presenting an install prompt|presentation of the install prompt">present
        an install prompt</dfn>:
      </p>
      <ol>
        <li>Show some user-agent-specific UI, asking the user whether to
        proceed with installing the app. The <var>result</var> of this choice
        is either {{AppBannerPromptOutcome/"accepted"}} or
        {{AppBannerPromptOutcome/"dismissed"}}.
        </li>
        <li>Return <var>result</var>, and <a>in parallel</a>:
          <ol>
            <li>If <var>result</var> is {{AppBannerPromptOutcome/"accepted"}},
            run the <a>steps to install the web application</a>.
            </li>
          </ol>
        </li>
      </ol>
      <p>
        The <dfn>steps to notify that an install prompt is available</dfn> are
        given by the following algorithm:
      </p>
      <ol>
        <li>Wait until the {{Document}} of the <a>top-level browsing
        context</a> is <a data-cite="html#completely-loaded">completely
        loaded</a>.
        </li>
        <li>If there is already an <a data-lt=
        "present an install prompt">install prompt being presented</a> or if
        the <a>steps to install the web application</a> are currently being
        executed, then abort this step.
        </li>
        <li>
          <a>Queue a task</a> on the <a>application life-cycle task source</a>
          to do the following:
          <ol>
            <li>Let |mayShowPrompt| be the result of [=fire an event=] named
            `"beforeinstallprompt"` at the [=top-level browsing context=]'s
            [=relevant global object=] using the {{BeforeInstallPromptEvent}}
            interface, with steps to initialize the {{Event/cancelable}}
            attribute to `true`.
            </li>
            <li>If |mayShowPrompt| is true, then the user agent MAY, <a>in
            parallel</a>, <a>request to present an install prompt</a> with
            |event|.
            </li>
          </ol>
        </li>
      </ol>
    </section>
    <section data-cite="DOM">
      <h2>
        Installable web applications
      </h2>
      <section>
        <h2>
          <dfn>Installation</dfn> process
        </h2>
        <p>
          The <dfn>steps to install the web application</dfn> are given by the
          following algorithm:
        </p>
        <ol>
          <li>Let <var>manifest</var> be the manifest of an installable
          document.
          </li>
          <li>Perform an unspecified sequence of actions to attempt to register
          the web application in the user's operating system (e.g., create
          shortcuts that launch the web application, register the application
          in the system uninstall menu, etc.). If the installation fails (which
          can be for any reason, for example, the OS denying permission to the
          user agent to add an icon to the home screen of the device), abort
          these steps.
          </li>
          <li>
            <a>Queue a task</a> on the <a>application life-cycle task
            source</a> to <a>fire an event</a> named `"appinstalled"` at the
            [=top-level browsing context=]'s [=relevant global object=] for
            which the installation took place.
          </li>
        </ol>
      </section>
      <section class="informative">
        <h3 id="installability-signals">
          Installability signals
        </h3>
        <p>
          By design, this specification does not provide developers with an
          explicit API to "install" a web application. Instead, a
          <a>manifest</a> can serve as an <dfn>installability signal</dfn> to a
          user agent that a web application can be installed.
        </p>
        <p>
          Examples of <a>installability signals</a> for a web application:
        </p>
        <ul>
          <li>has a [=application manifest=] with an application name and a
          suitable icon.
          </li>
          <li>is served over a secure network connection, but also functions
          without a network connection.
          </li>
          <li>has a sensible content security policy.
          </li>
          <li>is able to responsively adapt to display on a variety of screen
          sizes, catering for both mobile and desktop.
          </li>
          <li>shows a high degree of end-user engagement over an extended
          period of time.
          </li>
          <li>has been explicitly marked by the user as one that they value and
          trust (e.g., by bookmarking or "starring" it).
          </li>
        </ul>
        <p>
          This list is not exhaustive and some <a>installability signals</a>
          might not apply to all user agents. How a user agent makes use of
          these <a>installability signals</a> to determine if a web application
          can be installed is left to implementers.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Installation Events
      </h2>
      <p>
        [=event|Events=] of this specification rely on the <dfn>application
        life-cycle task source</dfn>.
      </p>
      <section data-dfn-for="BeforeInstallPromptEvent">
        <h3>
          <dfn>BeforeInstallPromptEvent</dfn> Interface
        </h3>
        <div class="note">
          The <a>beforeinstallprompt</a> event is somewhat misnamed, as it does
          not necessarily signal that a <a>manual installation</a> will follow
          (depending on the user agent, it might just be giving the site the
          ability to trigger an install prompt). It is so named for historical
          reasons.
        </div>
        <pre class="idl" data-cite="DOM">
          [Exposed=Window]
          interface BeforeInstallPromptEvent : Event {
            constructor(DOMString type, optional EventInit eventInitDict = {});
            Promise&lt;PromptResponseObject&gt; prompt();
          };

          dictionary PromptResponseObject {
            AppBannerPromptOutcome userChoice;
          };

          enum AppBannerPromptOutcome {
            "accepted",
            "dismissed"
          };
        </pre>
        <p>
          The {{BeforeInstallPromptEvent}} is dispatched when the site is
          allowed to present a <a>site-triggered install prompt</a>, or prior
          to the user agent presenting an <a>automated install prompt</a>. It
          allows the site to cancel the <a>automated install prompt</a>, as
          well as manually present the <a>site-triggered install prompt</a>.
        </p>
        <div class="note">
          If the {{BeforeInstallPromptEvent}} is <em>not</em> cancelled, the
          user agent is allowed to <a>present an install prompt</a>
          (specifically, an <a>automated install prompt</a>) to the end-user.
          Canceling the default action (via {{Event/preventDefault()}})
          prevents the user agent from <a>presenting an install prompt</a>. The
          user agent is free to run <a>steps to notify that an install prompt
          is available</a> again at a later time.
        </div>
        <p>
          The <dfn>PromptResponseObject</dfn> contains the result of calling
          {{BeforeInstallPromptEvent/prompt()}}. It contains one member,
          <dfn>userChoice</dfn>, which states the user's chosen outcome.
        </p>
        <p>
          An instance of a {{BeforeInstallPromptEvent}} has the following
          internal slots:
        </p>
        <dl data-dfn-for="BeforeInstallPromptEvent">
          <dt>
            <dfn>[[\didPrompt]]</dfn>
          </dt>
          <dd>
            A boolean, initially `false`. Represents whether this event was
            used to <a>present an install prompt</a> to the end-user.
          </dd>
          <dt>
            <dfn>[[\userResponsePromise]]</dfn>
          </dt>
          <dd>
            A promise that represents the outcome of <a>presenting an install
            prompt</a>.
          </dd>
        </dl>
        <section>
          <h4>
            <code>prompt()</code> method
          </h4>
          <p>
            The <dfn>prompt</dfn> method, when called, runs the following
            steps:
          </p>
          <ol>
            <li>Let |userResponsePromise| be
            {{BeforeInstallPromptEvent/[[userResponsePromise]]}}.
            </li>
            <li>If |userResponsePromise| is pending:
              <ol>
                <li>If [=this=].{{BeforeInstallPromptEvent/[[didPrompt]]}} is
                `true`, terminate this algorithm.
                </li>
                <li>If this event's {{Event/isTrusted}} attribute is `false`,
                reject |userResponsePromise| with {{"NotAllowedError"}} and
                terminate this algorithm.
                </li>
                <li>Set [=this=].{{BeforeInstallPromptEvent/[[didPrompt]]}} to
                `true`.
                </li>
                <li>
                  <a>In parallel</a>, <a>request to present an install
                  prompt</a> with [=this=]. Wait, possibly indefinitely, for
                  the end-user to make a choice.
                </li>
              </ol>
            </li>
            <li>Return |userResponsePromise|.
            </li>
          </ol>
          <p>
            To <dfn data-noexport="">request to present an install prompt</dfn>
            with {{BeforeInstallPromptEvent}} <var>event</var>:
          </p>
          <ol>
            <li>
              <a>Present an install prompt</a> and let |outcome| be the result.
            </li>
            <li>Let |response| be a newly created {{PromptResponseObject}},
            initializing its {{PromptResponseObject/userChoice}} to |outcome|.
            </li>
            <li>[=Resolve=]
            |event|.{{BeforeInstallPromptEvent/[[userResponsePromise]]}} with
            |response|.
            </li>
          </ol>
        </section>
        <section class="informative">
          <h4>
            Usage example
          </h4>
          <p>
            This example shows how one might prevent an automated install
            prompt from showing until the user clicks a button to show a
            <a>site-triggered install prompt</a>. In this way, the site can
            leave installation at the user's discretion (rather than prompting
            at an arbitrary time), whilst still providing a prominent UI to do
            so.
          </p>
          <pre class="example" title=
          "Using beforeinstallprompt to present an install button">
              window.addEventListener("beforeinstallprompt", event =&gt; {
                // Suppress automatic prompting.
                event.preventDefault();

                // Show the (disabled-by-default) install button. This button
                // resolves the installButtonClicked promise when clicked.
                installButton.disabled = false;

                // Wait for the user to click the button.
                installButton.addEventListener("click", async e =&gt; {
                  // The prompt() method can only be used once.
                  installButton.disabled = true;

                  // Show the prompt.
                  const { userChoice } = await event.prompt();
                  console.info(`user choice was: ${userChoice}`);
                });
              });
            </pre>
        </section>
        <section data-dfn-for="AppBannerPromptOutcome">
          <h4>
            <code>AppBannerPromptOutcome</code> enum
          </h4>
          <p>
            The <dfn>AppBannerPromptOutcome</dfn> enum's values represent the
            outcomes from <a>presenting an install prompt</a>.
          </p>
          <dl>
            <dt>
              "<dfn>accepted</dfn>":
            </dt>
            <dd>
              The end-user indicated that they would like the user agent to
              install the web application.
            </dd>
            <dt>
              "<dfn>dismissed</dfn>":
            </dt>
            <dd>
              The end-user dismissed the install prompt.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>
          Extensions to the `Window` object
        </h3>
        <pre class="idl" data-cite="HTML">
          partial interface Window {
            attribute EventHandler onappinstalled;
            attribute EventHandler onbeforeinstallprompt;
          };
        </pre>
        <section data-dfn-for="Window">
          <h4>
            <code>onappinstalled</code> attribute
          </h4>
          <p>
            The <dfn>onappinstalled</dfn> <a>event handler IDL attribute</a>
            handles "<dfn class="event">appinstalled</dfn>" events.
          </p>
        </section>
        <section>
          <h4>
            <code>onbeforeinstallprompt</code> attribute
          </h4>
          <p>
            The <dfn>onbeforeinstallprompt</dfn> <a>event handler IDL
            attribute</a> handles "<dfn class=
            "event">beforeinstallprompt</dfn>" events.
          </p>
        </section>
      </section>
    </section>
    <section data-cite="file-system-access permissions">
      <h2>
        Launch queue and launch params
      </h2>
      <section data-dfn-for="LaunchParams">
        <h3>
          <dfn>LaunchParams</dfn> interface
        </h3>
        <pre class="idl">
          [Exposed=Window] interface LaunchParams {
            readonly attribute DOMString? targetURL;
            readonly attribute FrozenArray&lt;FileSystemHandle&gt; files;
          };
        </pre>
        <p>
          {{LaunchParams/targetURL}} represents the [=URL=] of the launch which
          MUST be [=manifest/within scope=] of the application.
        </p>
        <p>
          For every |file handle:FileSystemHandle| in {{LaunchParams/files}},
          querying the file system permission with
          {{FileSystemPermissionDescriptor/mode}} set to
          {{FileSystemPermissionMode/"readwrite"}} MUST return
          {{PermissionState/"granted"}}.
        </p>
      </section>
      <section data-dfn-for="LaunchConsumer">
        <h3>
          <dfn>LaunchConsumer</dfn> function
        </h3>
        <pre class="idl">
          callback LaunchConsumer = any (LaunchParams params);
        </pre>
      </section>
      <section data-dfn-for="LaunchQueue">
        <h3>
          <dfn>LaunchQueue</dfn> interface
        </h3>
        <pre class="idl">
          partial interface Window {
            readonly attribute LaunchQueue launchQueue;
          };

          [Exposed=Window] interface LaunchQueue {
            undefined setConsumer(LaunchConsumer consumer);
          };
        </pre>
        <p>
          {{LaunchQueue}} has an <dfn>unconsumed launch params</dfn> which is a
          [=list=] of {{LaunchParams}} that is initially empty.
        </p>
        <p>
          {{LaunchQueue}} has an <dfn>assigned launch consumer</dfn> which is
          initially null.
        </p>
        <section>
          <h2>
            <dfn>setConsumer</dfn> method
          </h2>
          <p>
            The {{LaunchQueue/setConsumer(consumer)}} method steps are:
          </p>
          <ol class="algorithm">
            <li>Set the [=assigned launch consumer=] to |consumer|.
            </li>
            <li>[=list/For each=] |launch_params:LaunchParams| of [=unconsumed
            launch params=]:
              <ol>
                <li>Call |consumer| with |launch_params|.
                </li>
              </ol>
            </li>
            <li>Set [=unconsumed launch params=] to the empty list.
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>
          Handling Web App Launches
        </h3>
        <p>
          The steps to <dfn>launch a web app</dfn> are given by the following
          algorithm. The algorithm takes {{LaunchParams}}
          |params:LaunchParams|.
        </p>
        <ol class="algorithm">
          <li>If |params| is null, set |params| to a new {{LaunchParams}} with
          {{LaunchParams/targetURL}} set to [=manifest/start_url=].
          </li>
          <li>Append |params| to the [=unconsumed launch params=] of the
          launched document's {{Window.LaunchQueue}}.
          </li>
          <li>If the [=assigned launch consumer=] |consumer| is set:
            <ol>
              <li>[=list/For each=] |launch_params:LaunchParams| of
              [=unconsumed launch params=]:
                <ol>
                  <li>Call |consumer| with |launch_params|.
                  </li>
                </ol>
              </li>
              <li>Set [=unconsumed launch params=] to the empty list.
              </li>
            </ol>
          </li>
        </ol>
      </section>
    </section>
    <section id="conformance"></section>
  </body>
</html>
