<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Manifest Incubations
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class=
    "remove"></script>
    <script class='remove'>
      // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
      var respecConfig = {
        specStatus: "CG-DRAFT",
        editors: [{
          name: "Daniel Murphy"
        }],
        group: "wicg",
        github: "WICG/manifest-incubations",
        shortName: "manifest-incubations",
        xref: {
          specs: [
            "appmanifest",
            "dom",
            "file-system-access",
            "fs",
            "mimesniff",
            "urlpattern",
            "web-app-launch",
            "window-controls-overlay"
          ],
          profile: "web-platform",
        },
      };
    </script>
  </head>
  <body data-cite="MEDIAQUERIES-5">
    <section id="abstract">
      <p>
        Feature specifications for <a href=
        "https://www.w3.org/TR/appmanifest/">Web Application Manifest</a>
        extensions & incubations which Chromium has shipped but do not have
        committments / implementations from other user agents. Instead of
        keeping these features as explainers, they are documented more
        officially here.
      </p>
    </section>
    <section id="sotd">
      <p>
        This is an unofficial proposal.
      </p>
    </section>
    <section>
      <h2>
        <code><dfn data-export="" data-dfn-for=
        "manifest">display_override</dfn></code> member
      </h2>
      <p>
        For advanced usages, the [=manifest/display_override=] member can be
        used to specify a custom fallback order of <a data-cite=
        "appmanifest#dfn-display-modes-list">display mode list values</a> for
        developers to choose their preferred <a data-cite=
        "appmanifest#dfn-display">display mode</a> for the web application. Its
        value is a [=display mode=].
      </p>
      <p>
        The [=manifest/display_override=] member of the [=application
        manifest=] is a <a>sequence</a> of <a data-cite=
        "appmanifest#dfn-display-modes-list">display mode list values</a>
        including extensions like [=display mode/window-controls-overlay=] and
        [=display mode/borderless=]. This member represents the developer's
        preferred fallback chain for [=display mode=]s. This field overrides
        the [=manifest/display=] member. If the user agent does not support any
        of the [=display mode=]s specified here, then it falls back to
        considering the [=manifest/display=] member. See <a data-cite=
        "appmanifest#dfn-process-the-display-member">processing the display
        members</a> for the algorithm steps.
      </p>
      <p>
        The following steps are added to the [=application manifest/processing
        extension-point=] in <a data-cite=
        "appmanifest#dfn-steps-for-determining-the-web-app-s-chosen-display-mode">
        determining the web app's chosen display mode</a>:
      </p>
      <ol>
        <li>[=list/For each=] |candidate_display_mode:DisplayModeType| of
        |manifest:ordered map|.[=manifest/display_override=] member:
          <ol class="algorithm">
            <li>If <a data-cite="appmanifest/#dfn-display-modes-list">display
            modes list</a> contains |candidate_display_mode:DisplayModeType|,
            return that |candidate_display_mode:DisplayModeType|
            </li>
            <li>If |candidate_display_mode:DisplayModeType| is [=display
            mode/window-controls-overlay=] and the user agent supports this,
            then return that |candidate_display_mode:DisplayModeType|.
            </li>
            <li>If |candidate_display_mode:DisplayModeType| is [=display
            mode/tabbed=] and the user agent supports this, then return that
            |candidate_display_mode:DisplayModeType|.
            </li>
          </ol>
        </li>
      </ol>
      <p class="note">
        This member is intended to be only used for advanced cases, where the
        developer wants explicit control over the fallback order of their
        display modes, or for modes that are not available in the basic
        <a data-cite="appmanifest/#dfn-display-modes-list">display modes
        list</a>. Otherwise, the [=manifest/display=] member is sufficient for
        most use cases.
      </p>
      <section>
        <h3>
          Concepts
        </h3>
        <ul>
          <li>
            <dfn data-lt="controls of the window">Window controls</dfn>:
            interface elements that the operating system uses consistently
            across applications to enable the user to perform certain actions
            to control the application. Common actions in the [=window
            controls=] include minimize, maximize/restore, and close buttons.
          </li>
        </ul>
      </section>
      <section>
        <h3>
          Display mode extensions
        </h3>
        <p>
          Additionally to the normal <a data-cite=
          "appmanifest#dfn-display-modes-list">display modes</a>,
          [=manifest/display_override=] also supports certain extensions to it.
        </p>
        <dl>
          <dt>
            <dfn data-export="" data-dfn-for="display mode">borderless</dfn>
          </dt>
          <dd>
            The web application does not have any host-native title bar or
            [=window controls=] visible and with the web contents extended to
            the whole title bar area. The app can specify [=draggable region=]s
            in the web contents to create a customized title bar. The user
            agent may change the title bar state depending on various security
            considerations, like an out-of-scope navigation.
          </dd>
          <dt>
            [=display mode/window-controls-overlay=]
          </dt>
          <dt>
            <dfn data-export="" data-dfn-for="display mode">tabbed</dfn>
          </dt>
          <dd>
            The web application can have multiple application contexts combined
            in a single operating-system-level window. For example, this could
            mean the user agent displays a tab strip UI to allow the user to
            switch between the application contexts.
          </dd>
        </dl>
        <section class="informative">
          <h4>
            [=manifest/display_override=] usage example
          </h4>
          <p>
            The following shows a [=manifest=] that prefers the
            <code>minimal-ui</code> <a data-cite=
            "appmanifest#dfn-display-mode">display mode</a> over
            <code>standalone</code>, but if <code>minimal-ui</code> isn't
            supported, falls back to <code>standalone</code> as opposed to
            <code>browser</code>.
          </p>
          <pre class="example json" title="display_override usage manifest">
            {
              "name": "Recipe Zone",
              "description": "All of the recipes!",
              "icons": [{
                "src": "icon/hd_hi",
                "sizes": "128x128"
              }],
              "start_url": "/index.html",
              "display_override": ["minimal-ui"],
              "display": "standalone",
              "theme_color": "yellow",
              "background_color": "red"
            }
          </pre>
        </section>
      </section>
      <section>
        <h3>
          Defining <dfn data-export="" data-lt="draggable region">draggable
          regions</dfn>
        </h3>
        <p class="issue" title="At risk feature">
          [=app-region=] CSS property has not been implemented in any user
          agent, so it is at risk. Note that some user agents use the
          non-standard CSS property <dfn data-export="" data-lt=
          "-webkit-app-region">`-webkit-app-region`</dfn> for the same purpose.
        </p>
        <p>
          The <dfn data-export="" data-lt="app-region">`app-region`</dfn>
          property can be used to define with CSS which regions or elements in
          for example a title bar are draggable.
        </p>
        <ul>
          <li>To enable dragging an element, shall be set to `drag`.
          </li>
          <li>To disable dragging an element, shall be set to `no-drag`.
          </li>
        </ul>
      </section>
    </section>
    <section>
      <h2>
        Extensions to processing the manifest
      </h2>
      <p>
        To facilitate all of the new extension and incubation features added by
        this specification, the user agent SHOULD run the following during the
        <a data-cite=
        "appmanifest#dfn-processing-extension-point-of-web-manifest">extension
        point</a> in [=processing a manifest=] (having access to [=URL=]
        |document URL:URL|, [=URL=] |manifest URL:URL|, [=ordered map=]
        |json:ordered map|, and [=ordered map=] |manifest:ordered map|):
      </p>
      <ol>
        <li>[=Process the `note_taking` member=], passing |json|, |manifest|
        and |manifest URL|.
        </li>
        <li>[=Process the `protocol_handlers` member=], passing |json| and
        |manifest|.
        </li>
        <li>[=Process the `file_handlers` member=], passing |json|, |manifest|
        and |manifest URL|.
        </li>
      </ol>
    </section>
    <section>
      <h2>
        <code><dfn>tab_strip</dfn></code> member
      </h2>
      <p>
        The `tab_strip` member of the <a data-cite=
        "appmanifest#web-application-manifest">Web Application Manifest</a> is
        an <a data-cite="appmanifest#dfn-object">object</a> that contains
        information about how the application is intended to behave in the
        [=display mode/tabbed=] display mode. It has the following members:
      </p>
      <ul>
        <li>[=tab_strip/home_tab=]
        </li>
        <li>[=tab_strip/new_tab_button=]
        </li>
      </ul>
      <p class="issue" title="Missing exports from APPMANIFEST">
        "manifest URL" and "start URL" need to be exported from APPMANIFEST.
        See <a href=
        "https://github.com/w3c/manifest/pull/1112">w3c/manifest#1112</a>.
      </p>
      <section>
        <h3>
          <code><dfn>home_tab</dfn></code> member
        </h3>
        <p>
          The `home_tab` member of the [=tab_strip=] object is an ordered map
          that contains information about a specially marked [=application
          context=] that, if it exists, is in every app window. This
          application context has special properties compared to other
          application contexts, such as restricted navigation and it SHOULD
          have a different appearance.
        </p>
        <p>
          A <dfn>home tab context</dfn> is the [=application context=] in which
          these special properties are applied.
        </p>
        <aside class="note">
          The home tab is intended to serve as a top level menu for the app.
        </aside>
        <p>
          If the [=tab_strip/home_tab=] member is not present, then the
          application is not intended to have a home tab context, otherwise it
          is an ordered map with the following members:
        </p>
        <ul>
          <li>[=home_tab/scope_patterns=]
          </li>
        </ul>
        <p>
          How the [=home tab context=] is presented is at the discretion of the
          user agent.
        </p>
        <p>
          The <dfn>home tab scope</dfn> is the set of URLs to which the home
          tab context can be navigated to. All navigations within the
          application to a URL within the home tab scope will be done in the
          [=home tab context=], and all other navigations will be done in a
          different [=application context=].
        </p>
        <p>
          The [=home tab scope=] consists of the [=start URL=] and URLs that
          match a pattern specified in the [=scope_patterns=] field.
        </p>
        <aside class="note">
          Navigation to a URL within the [=home tab scope=] will open in the
          home tab, leaving behind the tab that initiated the navigation.
          Developers should ensure the tab left behind does not end up in an
          unexpected state.
        </aside>
        <section>
          <h4>
            <code><dfn>scope_patterns</dfn></code> member
          </h4>
          <p>
            The [=home_tab/scope_patterns=] member is a list of [=URL
            pattern=]s that define the scope of the home tab.
          </p>
          <p>
            If navigating from the home tab context to a [=URL=] |URL:url| that
            is outside of the [=home tab scope=], the following steps are run:
          </p>
          <ol>
            <li>Create a new [=application context=] in the current window.
            </li>
            <li>Navigate it to |url|.
            </li>
          </ol>
          <p>
            If navigating to a [=URL=] |URL:url| within the [=home tab scope=],
            the following steps are run:
          </p>
          <ol>
            <li>Focus the [=home tab context=].
            </li>
            <li>Navigate it to |url|.
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>
          <code><dfn>new_tab_button</dfn></code> member
        </h3>
        <p>
          The [=tab_strip/new_tab_button=] member is an ordered map that
          describes the behaviour of a UI affordance (such as a button) which,
          when clicked/activated, opens a new [=application context=] within
          the application window. It has the following members:
        </p>
        <ul>
          <li>[=new_tab_button/url=]
          </li>
        </ul>
        <p>
          If [=new_tab_button/url=] is within the [=home tab scope=], then the
          new tab button may be hidden.
        </p>
        <section>
          <h4>
            <code><dfn>url</dfn></code> member
          </h4>
          <p>
            The [=url=] member is a string that represents a URL relative to
            the [=manifest URL=] that is [=manifest/within scope=] of a
            [=Document/processed manifest=]. This URL will be navigated to when
            the new tab button is activated.
          </p>
        </section>
      </section>
      <section>
        <h2>
          Processing the `tab_strip` member
        </h2>To <dfn>process the `tab_strip` member</dfn>, given [=ordered
        map=] |json:ordered map|, [=ordered map=] |manifest:ordered map|, and
        [=URL=] |manifest URL:URL|, run the following during the <a data-cite=
        "appmanifest#dfn-processing-extension-point-of-web-manifest">extension
        point</a> in [=processing a manifest=]:
        <ol>
          <li>Set |manifest|["tab_strip"] to a new [=ordered map=].
          </li>
          <li>Set |manifest|["tab_strip"]["new_tab_button"]["url"] to
          |manifest|["start_url"].
          </li>
          <li>If |json|["tab_strip"] does not exist or |json|["tab_strip"] is
          not an [=ordered map=], return.
          </li>
          <li>[=Process the `home_tab` member=] passing |json|["tab_strip"],
          |manifest|["tab_strip"], and |manifest URL|.
          </li>
          <li>[=Process the `new_tab_button` member=] passing
          |json|["tab_strip"], |manifest|["tab_strip"], |manifest URL|, and
          |manifest|["start_url"].
          </li>
        </ol>
      </section>
      <section>
        <h2>
          Processing the `home_tab` member
        </h2>To <dfn>process the `home_tab` member</dfn>, given [=ordered map=]
        |json:ordered map|, [=ordered map=] |manifest tab strip:ordered map|,
        and [=URL=] |manifest URL:URL|, run the following:
        <ol>
          <li>If |json|["home_tab"] does not exist or |json|["home_tab"] not an
          [=ordered map=], return.
          </li>
          <li>Let |home tab:ordered map| be a new [=ordered map=].
          </li>
          <li>[=Process the `scope_patterns` member=] passing
          |json|["home_tab"]["scope_patterns"], |home tab| and |manifest URL|.
          </li>
          <li>Set |manifest tab strip|["home_tab"] to |home tab|.
          </li>
        </ol>
      </section>
      <section>
        <h2>
          Processing the `new_tab_button` member
        </h2>To <dfn>process the `new_tab_button` member</dfn>, given [=ordered
        map=] |json:ordered map|, [=ordered map=] |manifest tab strip:ordered
        map|, [=URL=] |manifest URL:URL|, and [=URL=] |start URL:URL|, run the
        following:
        <ol>
          <li>Set |manifest tab strip|["new_tab_button"]["url"] to |start URL|.
          </li>
          <li>If |json|["new_tab_button"] does not exist or
          |json|["new_tab_button"] is not an [=ordered map=], return.
          </li>
          <li>Let |url:URL| be the result of [=URL Parser|parsing=]
          |json|["new_tab_button"]["url"] with |manifest URL| as the base URL.
          </li>
          <li>If |url| is failure, return.
          </li>
          <li>If |url| is not [=URL/within scope=] of |manifest URL|, return.
          </li>
          <li>Set |manifest tab strip|["new_tab_button"]["url"] to |url|.
          </li>
        </ol>
      </section>
      <section>
        <h2>
          Processing the `scope_patterns` member
        </h2>To <dfn>process the `scope_patterns` member</dfn>, given [=ordered
        map=] |json:ordered map|, [=ordered map=] |manifest home tab:ordered
        map| and [=URL=] |manifest URL:URL|, run the following:
        <ol>
          <li>Let |processed scope patterns:list| be a new [=list=].
          </li>
          <li>Set |manifest home tab|["scope_patterns"] to |processed scope
          patterns|.
          </li>
          <li>If |json|["scope_patterns"] doesn't exist or
          |json|["scope_patterns"] is not a [=list=], return.
          </li>
          <li>For each |entry:URLPatternInit| of |json|["scope_patterns"]:
            <ol>
              <li>If |entry| is not an [=ordered map=], continue.
              </li>
              <li>Let |pattern:URL pattern| be the result of [=URL
              pattern/create|creating=] a [=URL pattern=] given |entry| and
              |manifest URL|.
              </li>
              <li>Set |pattern|'s [=URL pattern/search component=] and [=URL
              pattern/hash component=] to undefined.
              </li>
              <li>Append |pattern| to |processed scope patterns|.
              </li>
            </ol>
          </li>
        </ol>
        <p class="issue" title="TODO: Figure out how to clear search and hash">
          The "search component" and "hash component" of URL pattern are not
          exported. It isn't clear to me how we would go about setting them to
          undefined if they are private (you can't just set them to undefined
          in the input dictionary, because the `baseURL` can be used to set
          them). It's also not clear to me why we want to set them to
          undefined.
        </p>
      </section>
    </section>
    <section>
      <h2>
        `share_target` member
      </h2>
      <p>
        The `share_target` member registers a web application as "target" for
        share actions (e.g., for sharing a text, a URL, or a file). The
        `share_target` member is part of the [[[web-share-target]]]
        specification.
      </p>
    </section>
    <section>
      <h2>
        <code><dfn>note_taking</dfn></code> member
      </h2>
      <p>
        The `note_taking` member of the <a data-cite=
        "appmanifest#web-application-manifest">Web Application Manifest</a> is
        an <a data-cite="appmanifest#dfn-object">object</a> that contains
        information related to note-taking. It has the following members:
      </p>
      <ul>
        <li>[=note_taking/new_note_url=]
        </li>
      </ul>
      <p>
        A user agent MAY use these members to treat the web application
        differently as an application with note-taking capabilities (e.g.,
        integrate with operating system note-taking surfaces).
      </p>
      <section>
        <h3>
          <code><dfn data-dfn-for="note_taking">new_note_url</dfn></code>
          member
        </h3>
        <p>
          The [=note_taking=] `new_note_url` member is a [=string=] that
          represents the <a data-cite="url#concept-url">URL</a> the developer
          would prefer the user agent load when the user wants to take a new
          note using the web application (e.g., from an operating system
          shortcut icon or keyboard shortcut).
        </p>
        <p>
          The `new_note_url` member is purely advisory, and a user agent MAY
          <a data-cite="appmanifest#dfn-ignore">ignore</a> it or provide the
          end-user the choice of whether to use it. The user agent MAY provide
          the end-user the choice to modify it.
        </p>
        <aside class="note">
          <p>
            The `new_note_url` member is parsed with <a data-cite=
            "appmanifest#dfn-manifest-url">manifest URL</a> as the base URL and
            is ignored if not [=manifest/within scope=] of the manifest.
          </p>
        </aside>
      </section>
      <section class="informative">
        <h3>
          Usage Example
        </h3>
        <p>
          The following shows a [=manifest=] for a note-taking application.
        </p>
        <pre class="example json" title="Note-taking application">
          {
            "name": "My Note Taking App",
            "description": "You can take notes!",
            "icons": [{
              "src": "icon/hd_hi",
              "sizes": "128x128"
            }],
            "start_url": "/index.html",
            "display": "standalone",
            "note_taking": {
              "new_note_url": "/new_note.html"
            }
          }
        </pre>
      </section>
      <section>
        <h3>
          Processing the `note_taking` member
        </h3>
        <p>
          To <dfn>process the `note_taking` member</dfn>, given [=ordered map=]
          |json:ordered map|, [=ordered map=] |manifest:ordered map|, [=URL=]
          |manifest_URL:URL|, run the following during the <a data-cite=
          "appmanifest#dfn-processing-extension-point-of-web-manifest">extension
          point</a> in [=processing a manifest=]:
        </p>
        <ol class="algorithm">
          <li>If |json|["note_taking"] does not [=map/exist=], return.
          </li>
          <li>If the type of |json|["note_taking"] is not [=ordered map=],
          return.
          </li>
          <li>Set |manifest|["note_taking"] to a new [=ordered map=].
          </li>
          <li>[=process the `new_note_url` member=] passing
          |json|["note_taking"], |manifest|["note_taking"], and |manifest URL|.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Processing the `new_note_url` member
        </h3>
        <p>
          To <dfn>process the `new_note_url` member</dfn>, given [=ordered
          map=] |json_note_taking:ordered map|, [=ordered map=]
          |manifest_note_taking:ordered map|, [=URL=] |manifest_URL:URL|, run
          the following:
        </p>
        <ol class="algorithm">
          <li>If |json_note_taking|["new_note_url"] does not [=map/exist=],
          return.
          </li>
          <li>If the type of |json_note_taking|["new_note_url"] is not
          [=string=], return.
          </li>
          <li>Let |new_note_url:URL| be the result of [=URL Parser|parsing=]
          |json_note_taking|["new_note_url"] with |manifest URL| as the base
          URL.
          </li>
          <li>If |new_note_url| is failure, return.
          </li>
          <li>If |new_note_url| is not [=manifest/within scope=] of |manifest
          URL|, return.
          </li>
          <li>Set manifest_note_taking["new_note_url"] to |new_note_url|.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Launching the `new_note_url`
        </h3>
        <p>
          To <dfn>launch the `new_note_url`</dfn>, given <a data-cite=
          "appmanifest#dfn-processed-manifest">processed manifest</a>
          |manifest:processed manifest|, run the following steps:
        </p>
        <ol>
          <li>If |manifest|["note_taking"] does not [=map/exist=], return.
          </li>
          <li>If |manifest|["note_taking"]["new_note_url"] does not
          [=map/exist=], return.
          </li>
          <li>If the type of |manifest|["note_taking"]["new_note_url"] is not
          [=URL=], return.
          </li>
          <li>Run the steps to [=launch a web application=] setting |manifest|
          to |manifest| and |target URL| to
          |manifest|["note_taking"]["new_note_url"].
          </li>
        </ol>
        <p>
          The user agent MAY [=launch the `new_note_url`=] for a given
          [=installed web application=] at any time, typically in response to a
          user affordance.
        </p>
      </section>
    </section>
    <section>
      <h2>
        `protocol_handlers` member
      </h2>
      <p>
        The [=manifest's=] <code><dfn data-dfn-for=
        "manifest">protocol_handlers</dfn></code> member is an array of
        <a>protocol handler description</a>s that allows a web application to
        handle URL protocols.
      </p>
      <p>
        On installation, a user agent SHOULD register protocol handlers with
        the Operating System via interactions that are consistent with:
      </p>
      <ul>
        <li>If there are multiple registered handlers for a protocol, the OS
        allows the user to select which app should open it, and also allows the
        user to set a default app.
        </li>
        <li>Clicking on a registered protocol will launch the registered
        application. If this is the web app, then execute the [=invoke a
        protocol handler=] steps defined in [=HTML=], where the user agent
        SHOULD navigate to [=url=] and the appropriate browsing context is set
        to a new top level browsing context.
        </li>
      </ul>
      <aside class="note">
        Protocol handlers could, for instance, be used for web app
        communication where one app directly invokes another and passes data
        via custom protocol links.
      </aside>
      <section>
        <h3>
          Processing the `protocol_handlers` member
        </h3>
        <p>
          To <dfn>process the `protocol_handlers` member</dfn>, given
          [=object=] |json:JSON|, |manifest:ordered map|:
        </p>
        <ol>
          <li>Let |processedProtocolHandlers| be a new [=list=] of
          |json:JSON|["|protocol_handlers|"].
          </li>
          <li>Set manifest["|protocol_handlers|"] to
          |processedProtocolHandlers|.
          </li>
          <li>[=list/For each=] |protocol_handler| (<a>protocol handler
          description</a>):
            <ol>
              <li>If |protocol_handler|["protocol"] or
              |protocol_handler|["url"] is undefined, [=iteration/continue=].
              </li>
              <li>Let (|normalizedProtocol:string|, |normalizedUrl:URL|) be the
              result of running [=normalize protocol handler parameters=] with
              |protocol_handler|["protocol"], | protocol_handler|["url"] using
              |manifest URL| as the base URL, and [=this=]'s relevant
              [=environment settings object=]. If the result is failure,
              [=iteration/continue=].
              </li>
              <li>If |normalizedUrl| is not [=manifest/within scope=] of
              |manifest|, [=iteration/continue=].
              </li>
              <li>If |processedProtocolHandlers| [=list/contains=] the
              |normalizedUrl|, [=iteration/continue=].
              </li>
              <li>[=List/Append=] |protocol_handler| to
              |processedProtocolHandlers|.
              </li>
            </ol>
          </li>
          <li>[=list/For each=] |processedProtocolHandlers|, the user agent
          SHOULD [=register a protocol handler=].
          </li>
        </ol>
        <p>
          A user agent SHOULD ask users for permission before registering a
          [=protocol handler description=] <var>protocol_handler</var>s as the
          default handler for a protocol with the host operating system. A user
          agent MAY truncate the list of [=protocol handler description=]
          <var>protocol_handlers</var> presented in order to remain consistent
          with the conventions or limitations of the host operating system.
        </p>
        <aside class="example">
          <p>
            In the following example, the developer has included two [=protocol
            handler description=] <var>protocol_handler</var>s. Assuming the
            the manifest's URL is
            <samp>https://example.com/manifest.webmanifest</samp>:
          </p>
          <ul>
            <li>The first protocol handler would register to handle "web+music"
            URLs (e.g.: web+music://#1234). When activated, the user agent
            would instantiate a new[=top-level browsing context=] and navigate
            to
            <samp>https://example.com/play?songId=web+music://%231234</samp>.
            </li>
            <li>The second protocol handler would be ignored, as the protocol
            provided does not start with "web+" and is not part of the
            [=safelisted schemes=].
            </li>
          </ul>
          <pre class="json">
            {
              "protocol_handlers": [
                {
                  "protocol": "web+music",
                  "url": "/play?songId=%s"
                },
                {
                  "protocol": "store",
                  "url": "/buy?songId=%s"
                }
              ]
            }
          </pre>
        </aside>
      </section>
      <section>
        <h2>
          Protocol handler items
        </h2>
        <p>
          Each <dfn>protocol handler description</dfn> is an [=object=] that
          represents a protocol that the web application wants to handle,
          corresponding to the [=manifest/protocol_handlers=] member. It has
          the following members:
        </p>
        <ul>
          <li>[=protocol handler description/protocol=]
          </li>
          <li>[=protocol handler description/url=]
          </li>
        </ul>
        <p>
          A user agent SHOULD use these values to register the web application
          as a handler with the operating system. When the user activates a
          protocol handler URL, the user agent SHOULD run <a>handling a
          protocol launch</a>.
        </p>
        <p class="note">
          [[HTML]]'s {{NavigatorContentUtils/registerProtocolHandler()}} allows
          web sites to register themselves as possible handlers for particular
          protocols. What constitutes valid [=protocol handler
          description/protocol=] and [=protocol handler description/url=]
          values for <a>protocol handler description</a>s is defined in that
          API. Also note that the [[HTML]] API uses <code>scheme</code> where
          we use [=protocol handler description/protocol=] but the same
          restrictions apply.
        </p>
        <section>
          <h3>
            `protocol` member
          </h3>
          <p>
            The <code><dfn data-dfn-for=
            "protocol handler description">protocol</dfn></code> member of a
            <a>protocol handler description</a> is a <a>string</a> that
            represents the protocol to be handled, such as `mailto` or
            `web+auth`.
          </p>
          <p>
            The [=protocol handler description/protocol=] member of a
            <a>protocol handler description</a> is equivalent to
            {{NavigatorContentUtils/registerProtocolHandler()}}'s
            <code>scheme</code> argument defined in [[HTML]].
          </p>
        </section>
        <section>
          <h3>
            `url` member
          </h3>
          <p>
            The <code><dfn data-dfn-for=
            "protocol handler description">url</dfn></code> member of a
            <a>protocol handler description</a> is the <a>URL</a>
            [=manifest/within scope=] of the application that opens when the
            associated protocol is activated.
          </p>
          <p>
            The [=protocol handler description/url=] member of a <a>protocol
            handler description</a> is equivalent to
            {{NavigatorContentUtils/registerProtocolHandler()}}'s
            <code>url</code> argument defined in [[HTML]].
          </p>
        </section>
        <section>
          <h3>
            <dfn>Handling a protocol launch</dfn>
          </h3>
          <p>
            When a <a>protocol handler description</a>
            <var>protocol_handler</var> having [=manifest=] <var>manifest</var>
            is invoked, it goes through the same steps used to [=invoke a
            protocol handler=] where the user agent, instead of [=navigating=]
            to <var>resultURL</var>, SHOULD [=launch a web application=]
            passing <var>manifest</var> and <var>resultURL</var>.
          </p>
          <p class="issue">
            This should not invoke and alter [=invoke a protocol handler=] in
            this way. The computation of <var>resultURL</var> should be
            extracted out into a separate algorithm for general use.
          </p>
        </section>
      </section>
      <section>
        <h2>
          Privacy consideration: Default protocol handler
        </h2>
        <p>
          Depending on the operating system capabilities, the protocol handler
          could become a 'default' handler (e.g. handling launches of a given
          protocol automatically) of a given protocol without the explicit
          knowledge of the user. To protect against possible misuse, user
          agents MAY employ protections such as:
        </p>
        <ul>
          <li>Requiring explicit user consent before executing the process to
          [=invoke a protocol handler=].
          </li>
          <li>Removing the web application's OS registration as a protocol
          handling entity, either in response to the above dialog or by user
          action.
          </li>
          <li>Confirming protocol handler registrations on [=installation=].
          </li>
        </ul>
        <p>
          If a user agent removes the the registration of the protocol handler
          entity it SHOULD provide UX for the user to re-register the web app
          and protocol with the operating system.
        </p>
      </section>
    </section>
    <section>
      <h3>
        `file_handlers` member
      </h3>
      <p>
        The [=manifest's=] <code><dfn data-export="" data-dfn-for=
        "manifest">file_handlers</dfn></code> member is a [=list=] that
        provides instructions for how the app handles file-opening actions that
        originate outside of the app itself.
      </p>
      <p>
        The management, presentation, and selection of registered file-handling
        applications is at the discretion of the operating system.
      </p>
      <p>
        To <dfn>process the `file_handlers` member</dfn>, given [=ordered map=]
        |json:ordered map|, [=ordered map=] |manifest:ordered map|, [=URL=]
        |manifest_url:URL|:
      </p>
      <ol class="algorithm">
        <li>Let |processedFileHandlers:list| be a new [=list=].
        </li>
        <li>Set |manifest|["file_handlers"] to |processedFileHandlers|.
        </li>
        <li>If |json|["file_handlers"] doesn't [=map/exist=] or
        |json|["file_handlers"] is not a [=list=], return.
        </li>
        <li>[=list/For each=] |entry:ordered map| of |json|["file_handlers"]:
          <ol>
            <li>Let |file_handler:ordered map| be [=process a file handler
            item=] with |entry|, [=manifest/start_url=], [=manifest/scope=],
            and |manifest_url|.
            </li>
            <li>If |file_handler| is failure, [=iteration/continue=].
            </li>
            <li>[=list/Append=] |file_handler| to |processedFileHandlers|.
            </li>
          </ol>
        </li>
      </ol>
      <p>
        On [=installation=], a user agent SHOULD run the process to [=register
        file handlers=].
      </p>
      <section data-cite="file-system-access">
        <h2>
          File Handler Items
        </h2>
        <p>
          Each <dfn data-local-lt="file handler">file handler</dfn> represents
          a URL in the scope of the application that can handle launches with
          [=file types=] it accepts. It has the following members:
        </p>
        <ul>
          <li>[=file handler/action=]
          </li>
          <li>[=file handler/name=]
          </li>
          <li>[=file handler/accept=]
          </li>
          <li>[=file handler/icons=]
          </li>
        </ul>
        <p>
          A user agent can use these members to associate the web application
          with [=file type=] on the operating system.
        </p>
        <p>
          A <dfn>file type</dfn> can be defined by a [=MIME type=] and/or
          [=file extension=]. A file belongs to a file type if the OS
          determines it to have a [=MIME type=] and/or its name ends with a
          certain [=file extension=]. A <dfn>file extension</dfn> is a string
          that start with a "." and only contains <a data-cite=
          "file-system-access#valid-suffix-code-points">valid suffix code
          points</a>. Additionally, [=file extensions=] are limited to a length
          of 16 code points.
        </p>
        <section>
          <h3>
            `action` member
          </h3>
          <p>
            The [=file handler=]'s <code><dfn data-dfn-for=
            "file handler">action</dfn></code> member is a <a>string</a> that
            represents a URL relative to the <a data-cite=
            "appmanifest#dfn-manifest-url">manifest URL</a> that is
            [=manifest/within scope=] of a <a data-cite=
            "appmanifest#dfn-processed-manifest">processed manifest</a> . This
            URL will be navigated to in the steps to [=execute a file handler
            launch=].
          </p>
        </section>
        <section>
          <h3>
            `name` member
          </h3>
          <p>
            The [=file handler=]'s <code><dfn data-dfn-for=
            "file handler">name</dfn></code> member is a <a>string</a> that
            identifies the file type to the user. [=User agents=] MAY pass this
            information to the operating system during file handler
            registration.
          </p>
          <aside class="note">
            <p>
              The [=file handler/name=] is used to identify and describe the
              file type in a human readable format, and is typically only
              displayed in OS surfaces (such as a file browser) if the web app
              has become the default handler for that file type. It's most
              useful for custom file types.
            </p>
          </aside>
        </section>
        <section>
          <h3>
            `icons` member
          </h3>
          <p>
            The <a>file handler</a>'s <code><dfn data-dfn-for=
            "file handler">icons</dfn></code> member lists icons that serve as
            graphical representations of a [=file type=]. User agents MAY pass
            this information to the operating system during file handler
            registration.
          </p>
          <aside class="note">
            The [=file handler/icons=] member is expected to be an image (or
            collection of images at different sizes) that represents all files
            that are associated with the handler. This will typically appear
            like a document (e.g. a piece of paper) as opposed to an
            application logo, but might include elements (such as logos) that
            suggest which application the file is associated with. As with
            [=file handler/name=], this is typically only displayed when the
            app has become the default handler for a file type.
          </aside>
        </section>
        <section>
          <h3>
            `accept` member
          </h3>
          <p>
            The [=file handler=]'s <code><dfn data-dfn-for=
            "file handler">accept</dfn></code> member is a <a>dictionary</a>
            mapping [=MIME types=] to a list of [=file extensions=].
          </p>
          <p>
            [=User agents=] MUST enforce that the [=file handler/accept=] entry
            only applies to files that have a matching extension.
          </p>
          <p>
            In order to [=register file handlers=], some operating systems
            require [=MIME types=] and some require [=file extensions=]. Thus
            the manifest MUST always provide both for each [=file
            handler/accept=] entry.
          </p>
          <p>
            In addition to complete [=MIME types=], <code>"*"</code> can be
            used as the subtype of a [=MIME type=] to match, for example, all
            image formats with <code>"image/*"</code> (that also apply to the
            provided list of [=file extensions=]).
          </p>
          <aside class="note">
            For example, on Linux both the [=MIME type=] and [=file extension=]
            is used with the <code>xdg-mime</code> utility to specify that the
            web application can open files with both the [=MIME type=]
            specified and the specific file extension. On Windows, only [=file
            extensions=] are used, so the [=MIME types=] are ignored.
          </aside>
        </section>
        <section>
          <h3>
            `launch_type` member
          </h3>
          <p>
            The [=file handler=]'s <code><dfn data-dfn-for=
            "file handler">launch_type</dfn></code> member is a <a>string</a>
            that determines how the app is launched for files routed to this
            handler. The possible values are `"single-client"` and
            `"multiple-clients"`. If not provided, it defaults to
            `"single-client"`.
          </p>
          <p>
            When a [=file handler=] is determined to match a set of files, the
            [=user agent=] SHOULD use [=file handler/launch_type=] to control
            whether the app is launched once for each file
            (`"multiple-clients"`), or one time for all files
            (`"single-client"`). See {{LaunchParams/files}}. The user agent
            MUST NOT coalesce files from different [=file handlers=] into a
            single launch event.
          </p>
          <aside class="note">
            <p>
              If an app is only meant to display one file per window or tab,
              `"multiple-clients"` should be applied. Otherwise, one instance
              will be launched and all opened files will be passed via the
              {{LaunchParams/files}} array.
            </p>
            <p>
              This field is subject to platform limitations. Windows never
              launches an app with multiple files, but will launch a single app
              multiple times with one file each. As such, this field has no
              effect on Windows and all launches are effectively
              `"multiple-clients"`.
            </p>
          </aside>
        </section>
      </section>
      <section>
        <h2>
          Processing file handler items
        </h2>
        <p>
          To <dfn>process a file handler item</dfn>, given [=ordered map=]
          |item:ordered map|, [=URL=] |start_url:URL|, [=URL=] |scope:URL|, and
          [=URL=] |manifest URL:URL|:
        </p>
        <ol class="algorithm">
          <li>Return failure if any of the following is true:
            <ul>
              <li>|item|["action"] doesn't [=map/exist=] or is not a
              [=string=].
              </li>
              <li>|item|["accept"] doesn't [=map/exist=].
              </li>
              <li>|item|["accept"] is not a [=dictionary=].
              </li>
              <li>|item|["accept"] [=map/is empty=].
              </li>
            </ul>
          </li>
          <li>Let |url:URL| be the result of [=URL Parser|parsing=]
          |item|["action"] with |manifest_url URL| as the base URL.
          </li>
          <li>If |url| is failure, return failure.
          </li>
          <li>If |url| is not [=manifest/within scope=] of |scope|, return
          failure.
          </li>
          <li>Let |launch_type:string| be a new [=string=] initialized to
          "single-client".
          </li>
          <li>If |item|["launch_type"] [=map/exists=] and is
          "multiple-clients", set |launch_type| to |item|["launch_type"].
          </li>
          <li>Let |accept:ordered map| be a new [=ordered map=].
          </li>
          <li>[=map/for each=] |mime_type_string:string| → |extensions| of
          |item|["accept"]
            <ol>
              <li>If |extensions| is not a [=list=], [=iteration/continue=].
              </li>
              <li>If |extensions| is [=list/empty=], [=iteration/continue=].
              </li>
              <li>If |extensions| [=list/contains=] items that are not
              [=string=]s, [=iteration/continue=].
              </li>
              <li>If |extensions| [=list/contains=] strings that do not begin
              with the character `.`, [=iteration/continue=].
              </li>
              <li>If |extensions| [=list/contains=] strings that are greater
              than 16 characters long, [=iteration/continue=].
              </li>
              <li>Let |mime_type_parsed:mime type| be the result of running the
              steps of [=parse a mime type=] on |mime_type_string|.
              </li>
              <li>If |mime_type_parsed:mime type| is failure,
              [=iteration/continue=].
              </li>
              <li>If |mime_type_parsed/type| is not listed as a top-level type
              in [[IANA-MEDIA-TYPES]], [=iteration/continue=].
              </li>
              <li>Set |accept|[|mime_type_string|] to |extensions|.
              </li>
            </ol>
          </li>
          <li>If |accept:ordered map| is empty, return failure.
          </li>
          <li>Let |file_handler:ordered map| be |ordered map| «[ "action" →
          |url|, "name" → |item|["name"], "launch_type" → |launch_type|,
          "accept" → |accept| ]».
          </li>
          <li>
            <a data-cite="appmanifest#dfn-process-image-resources">Process
            image resources</a> passing |item|["icons"], |file_handler|,
            |manifest URL|, and "icons".
          </li>
          <li>Return |file_handler|.
          </li>
        </ol>
      </section>
      <section>
        <h2>
          Execute a file handler launch
        </h2>
        <p>
          The steps to <dfn>execute a file handler launch</dfn> are given by
          the following algorithm. The algorithm takes [=list=] |files:list|
          and a [=ordered map=] |manifest:ordered_map| which holds results from
          [=processing a manifest=].
        </p>
        <ol class="algorithm">
          <li>Let |file_handlers:list| be |manifest|["file_handlers"].
          </li>
          <li>If |file_handlers:list| is null, return.
          </li>
          <li>Let |launches:ordered map| be an [=ordered map=].
          </li>
          <li>[=list/for each=] |filename:string| of |files|
            <ol>
              <li>[=list/for each=] |file_handler:ordered_map| of
              |file_handlers:list|:
                <ol>
                  <li>[=map/for each=] |mime_type_string:string| →
                  |extensions:list| of |file_handler|["accept"]
                    <ol>
                      <li>[=list/for each=] |extension:string| of |extensions|:
                        <ol>
                          <li>If |filename| does not end in |extension|,
                          [=iteration/continue=].
                          </li>
                          <li>If |launches|[|file_handler|] [=map/exists=],
                          [=list/append=] |filename| to
                          |launches|[|file_handler|].
                          </li>
                          <li>Else, set |launches|[|file_handler|] to a
                          [=list=] with the single element |filename|.
                          </li>
                          <li>[=iteration/Continue=] to next element of
                          |files|.
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>[=map/for each=] |file_handler| → |files:list| of |launches|
            <ol>
              <li>If |file_handler|["launch_type"] is equal to
              "multiple-clients"
                <ol>
                  <li>[=list/for each=] |file| of |files|
                    <ol>
                      <li>Let |params:LaunchParams| be a new {{LaunchParams}}
                      with {{LaunchParams/files}} set to a {{FrozenArray}} with
                      a single element that is a {{FileSystemHandle}}
                      corresponding to |file|.
                      </li>
                      <li>[=Launch a web application with handling=], passing
                      |manifest| and |params|.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Else,
                <ol>
                  <li>Let |params:LaunchParams| be a new {{LaunchParams}} with
                  {{LaunchParams/files}} set to a {{FrozenArray}} of
                  {{FileSystemHandle}}s that correspond to the file paths named
                  by |files|.
                  </li>
                  <li>[=Launch a web application with handling=], passing
                  |manifest| and |params|.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Registering file handlers
        </h3>
        <p>
          A user agent SHOULD <dfn>register file handlers</dfn> with the host
          operating system, consistent with:
        </p>
        <ul>
          <li>The app is exposed in appropriate OS surfaces such as the native
          file browser and other surfaces that display lists of apps that can
          handle a given file or file type.
          </li>
          <li>The app is a candidate for becoming the system's default handler
          for associated file types.
          </li>
        </ul>
        <p>
          A user agent MAY truncate the total set of [=file extensions=] to
          preserve functionality and prevent abuse. A user agent MAY prevent
          associations with certain filetypes.
        </p>
      </section>
      <section>
        <h3>
          Privacy consideration: Default file handler.
        </h3>
        <p>
          Depending on the operating system capabilities, the [=file handler=]
          could become a default handler of a given [=file type=] without the
          explicit knowledge of the user, handling launches of a given file
          type automatically. To protect against possible mis-use, [=user
          agents=] MAY require explicit user consent to begin with the process
          to [=execute a file handler launch=]. If consent is sought, the user
          agent SHOULD allow the user to specify that the decision is permanent
          and if so specified SHOULD remove the web application's OS
          registration as a file handling entity.
        </p>
      </section>
      <section>
        <h3>
          Privacy consideration: Name and icon.
        </h3>
        <p>
          The name and icon of each file handler can be sensitive to privacy
          and security, as there isn't a specified way for the user to see and
          confirm these. Due to this, [=user agents=] MAY choose to ignore
          these in favor of alternative strings and icons or fall back on OS
          defaults.
        </p>
      </section>
      <section class="informative">
        <h3>
          Example manifest with file handlers
        </h3>
        <p>
          In the following example, the web application has 3 different file
          handlers.
        </p>
        <aside class="example">
          <pre class="json">
            {
              "name": "Grafr",
              "file_handlers": [
                {
                  "action": "/open-csv",
                  "accept": {
                    "text/csv": [ ".csv" ],
                    "text/plain": [ ".txt" ]
                  }
                },
                {
                  "action": "/open-svg",
                  "accept": {
                    "image/svg+xml": [ ".svg" ]
                  }
                },
                {
                  "action": "/open-grafr",
                  "name": "Grafr graph",
                  "accept": {
                    "application/vnd.grafr-graph": [
                      ".grafr", ".graf"
                    ]
                  },
                  "launch_type": "multiple-clients",
                  "icons": [
                    {
                      "src": "/grafr-file.png",
                      "sizes": "144x144"
                    }
                  ]
                }
              ]
            }
          </pre>
        </aside>
      </section>
    </section>
    <section data-cite="DOM">
      <h2>
        Installation prompts
      </h2>
      <p>
        There are multiple ways that the installation process can be triggered:
      </p>
      <ul>
        <li>An end-user can <dfn data-lt="manual installation">manually</dfn>
        trigger the installation process through the user agent's
          <abbr title="User Interface">UI</abbr>, directly invoking the steps
          to <a>present an install prompt</a>.
        </li>
        <li>The installation process can occur through an <dfn>automated
        install prompt</dfn>: that is, a UI that the user agent presents to the
        user when, for instance, there are sufficient <a>installability
        signals</a> to warrant installation of the web application.
        </li>
        <li>The installation process can occur through a <dfn>site-triggered
        install prompt</dfn>: the site can programmatically request that the
        user agent present an install prompt to the user. The user agent MAY
        restrict the availability of this feature to cases where, for instance,
        there are sufficient signals to warrant [=installed web
        application|installation=] of the web application.
        </li>
      </ul>
      <p>
        In any case, the user agent MUST NOT <a>present an install prompt</a>
        if the document is not installable.
      </p>
      <p>
        The user agent MAY, at any time (only if the document is installable),
        run the <a>steps to notify that an install prompt is available</a> at
        any time, giving the site the opportunity to show a <a>site-triggered
        install prompt</a> without the user needing to interact with the user
        agent UI.
      </p>
      <p>
        To <dfn data-local-lt=
        "presenting an install prompt|presentation of the install prompt">present
        an install prompt</dfn>:
      </p>
      <ol>
        <li>Show some user-agent-specific UI, asking the user whether to
        proceed with installing the app. The <var>result</var> of this choice
        is either {{AppBannerPromptOutcome/"accepted"}} or
        {{AppBannerPromptOutcome/"dismissed"}}.
        </li>
        <li>Return <var>result</var>, and <a>in parallel</a>:
          <ol>
            <li>If <var>result</var> is {{AppBannerPromptOutcome/"accepted"}},
            run the <a>steps to install the web application</a>.
            </li>
          </ol>
        </li>
      </ol>
      <p>
        The <dfn>steps to notify that an install prompt is available</dfn> are
        given by the following algorithm:
      </p>
      <ol>
        <li>Wait until the {{Document}} of the <a>top-level browsing
        context</a> is <a data-cite="html#completely-loaded">completely
        loaded</a>.
        </li>
        <li>If there is already an <a data-lt=
        "present an install prompt">install prompt being presented</a> or if
        the <a>steps to install the web application</a> are currently being
        executed, then abort this step.
        </li>
        <li>
          <a>Queue a task</a> on the <a>application life-cycle task source</a>
          to do the following:
          <ol>
            <li>Let |mayShowPrompt| be the result of [=fire an event=] named
            `"beforeinstallprompt"` at the [=top-level browsing context=]'s
            [=relevant global object=] using the {{BeforeInstallPromptEvent}}
            interface, with steps to initialize the {{Event/cancelable}}
            attribute to `true`.
            </li>
            <li>If |mayShowPrompt| is true, then the user agent MAY, <a>in
            parallel</a>, <a>request to present an install prompt</a> with
            |event|.
            </li>
          </ol>
        </li>
      </ol>
    </section>
    <section data-cite="DOM">
      <h2>
        Installable web applications
      </h2>
      <section>
        <h2>
          <dfn>Installation</dfn> process
        </h2>
        <p>
          The <dfn>steps to install the web application</dfn> are given by the
          following algorithm:
        </p>
        <ol>
          <li>Let <var>manifest</var> be the manifest of an installable
          document.
          </li>
          <li>Perform an unspecified sequence of actions to attempt to register
          the web application in the user's operating system (e.g., create
          shortcuts that launch the web application, register the application
          in the system uninstall menu, etc.). If the installation fails (which
          can be for any reason, for example, the OS denying permission to the
          user agent to add an icon to the home screen of the device), abort
          these steps.
          </li>
          <li>
            <a>Queue a task</a> on the <a>application life-cycle task
            source</a> to <a>fire an event</a> named `"appinstalled"` at the
            [=top-level browsing context=]'s [=relevant global object=] for
            which the installation took place.
          </li>
        </ol>
      </section>
      <section class="informative">
        <h3 id="installability-signals">
          Installability signals
        </h3>
        <p>
          By design, this specification does not provide developers with an
          explicit API to "install" a web application. Instead, a
          <a>manifest</a> can serve as an <dfn>installability signal</dfn> to a
          user agent that a web application can be installed. These signals
          will vary per user agent, as each user agent will have its own
          heuristics to determine whether a web site is elegible of an install
          prompt. Implementers generally will provide documentation that
          describe their particular installabilty signals or other relevant
          criteria a web application needs to meet to be deemed installable.
        </p>
        <p>
          Examples of possible <a>installability signals</a> for a web
          application that a user agent might implement:
        </p>
        <ul>
          <li>has a [=application manifest=] with an application name and a
          suitable icon.
          </li>
          <li>is served over a secure network connection, but also functions
          without a network connection.
          </li>
          <li>has a sensible content security policy.
          </li>
          <li>is able to responsively adapt to display on a variety of screen
          sizes, catering for both mobile and desktop.
          </li>
          <li>shows a high degree of end-user engagement over an extended
          period of time.
          </li>
          <li>has been explicitly marked by the user as one that they value and
          trust (e.g., by bookmarking or "starring" it).
          </li>
        </ul>
        <p>
          This list is not exhaustive and some <a>installability signals</a>
          might not apply to all user agents. How a user agent makes use of
          these <a>installability signals</a> to determine if a web application
          can be installed is left to implementers.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Installation Events
      </h2>
      <p>
        [=event|Events=] of this specification rely on the <dfn>application
        life-cycle task source</dfn>.
      </p>
      <section data-dfn-for="BeforeInstallPromptEvent">
        <h3>
          <dfn>BeforeInstallPromptEvent</dfn> Interface
        </h3>
        <div class="note">
          The <a>beforeinstallprompt</a> event is somewhat misnamed, as it does
          not necessarily signal that a <a>manual installation</a> will follow
          (depending on the user agent, it might just be giving the site the
          ability to trigger an install prompt). It is so named for historical
          reasons.
        </div>
        <pre class="idl" data-cite="DOM">
          [Exposed=Window]
          interface BeforeInstallPromptEvent : Event {
            constructor(DOMString type, optional EventInit eventInitDict = {});
            Promise&lt;PromptResponseObject&gt; prompt();
          };

          dictionary PromptResponseObject {
            AppBannerPromptOutcome userChoice;
          };

          enum AppBannerPromptOutcome {
            "accepted",
            "dismissed"
          };
        </pre>
        <p>
          The {{BeforeInstallPromptEvent}} is dispatched when the site is
          allowed to present a <a>site-triggered install prompt</a>, or prior
          to the user agent presenting an <a>automated install prompt</a>. It
          allows the site to cancel the <a>automated install prompt</a>, as
          well as manually present the <a>site-triggered install prompt</a>.
        </p>
        <div class="note">
          If the {{BeforeInstallPromptEvent}} is <em>not</em> cancelled, the
          user agent is allowed to <a>present an install prompt</a>
          (specifically, an <a>automated install prompt</a>) to the end-user.
          Canceling the default action (via {{Event/preventDefault()}})
          prevents the user agent from <a>presenting an install prompt</a>. The
          user agent is free to run <a>steps to notify that an install prompt
          is available</a> again at a later time.
        </div>
        <p>
          The <dfn>PromptResponseObject</dfn> contains the result of calling
          {{BeforeInstallPromptEvent/prompt()}}. It contains one member,
          <dfn data-dfn-for="PromptResponseObject">userChoice</dfn>, which
          states the user's chosen outcome.
        </p>
        <p>
          An instance of a {{BeforeInstallPromptEvent}} has the following
          internal slots:
        </p>
        <dl data-dfn-for="BeforeInstallPromptEvent">
          <dt>
            <dfn>[[\didPrompt]]</dfn>
          </dt>
          <dd>
            A boolean, initially `false`. Represents whether this event was
            used to <a>present an install prompt</a> to the end-user.
          </dd>
          <dt>
            <dfn>[[\userResponsePromise]]</dfn>
          </dt>
          <dd>
            A promise that represents the outcome of <a>presenting an install
            prompt</a>.
          </dd>
        </dl>
        <section>
          <h4>
            <code>prompt()</code> method
          </h4>
          <p>
            The <dfn>prompt</dfn> method, when called, runs the following
            steps:
          </p>
          <ol>
            <li>Let |userResponsePromise| be
            {{BeforeInstallPromptEvent/[[userResponsePromise]]}}.
            </li>
            <li>If |userResponsePromise| is pending:
              <ol>
                <li>If [=this=].{{BeforeInstallPromptEvent/[[didPrompt]]}} is
                `true`, terminate this algorithm.
                </li>
                <li>If this event's {{Event/isTrusted}} attribute is `false`,
                reject |userResponsePromise| with {{"NotAllowedError"}} and
                terminate this algorithm.
                </li>
                <li>Set [=this=].{{BeforeInstallPromptEvent/[[didPrompt]]}} to
                `true`.
                </li>
                <li>
                  <a>In parallel</a>, <a>request to present an install
                  prompt</a> with [=this=]. Wait, possibly indefinitely, for
                  the end-user to make a choice.
                </li>
              </ol>
            </li>
            <li>Return |userResponsePromise|.
            </li>
          </ol>
          <p>
            To <dfn data-noexport="">request to present an install prompt</dfn>
            with {{BeforeInstallPromptEvent}} <var>event</var>:
          </p>
          <ol>
            <li>
              <a>Present an install prompt</a> and let |outcome| be the result.
            </li>
            <li>Let |response| be a newly created {{PromptResponseObject}},
            initializing its {{PromptResponseObject/userChoice}} to |outcome|.
            </li>
            <li>[=Resolve=]
            |event|.{{BeforeInstallPromptEvent/[[userResponsePromise]]}} with
            |response|.
            </li>
          </ol>
        </section>
        <section class="informative">
          <h4>
            Usage example
          </h4>
          <p>
            This example shows how one might prevent an automated install
            prompt from showing until the user clicks a button to show a
            <a>site-triggered install prompt</a>. In this way, the site can
            leave installation at the user's discretion (rather than prompting
            at an arbitrary time), whilst still providing a prominent UI to do
            so.
          </p>
          <pre class="example" title=
          "Using beforeinstallprompt to present an install button">
              window.addEventListener("beforeinstallprompt", event =&gt; {
                // Suppress automatic prompting.
                event.preventDefault();

                // Show the (disabled-by-default) install button. This button
                // resolves the installButtonClicked promise when clicked.
                installButton.disabled = false;

                // Wait for the user to click the button.
                installButton.addEventListener("click", async e =&gt; {
                  // The prompt() method can only be used once.
                  installButton.disabled = true;

                  // Show the prompt.
                  const { userChoice } = await event.prompt();
                  console.info(`user choice was: ${userChoice}`);
                });
              });
            </pre>
        </section>
        <section data-dfn-for="AppBannerPromptOutcome">
          <h4>
            <code>AppBannerPromptOutcome</code> enum
          </h4>
          <p>
            The <dfn>AppBannerPromptOutcome</dfn> enum's values represent the
            outcomes from <a>presenting an install prompt</a>.
          </p>
          <dl>
            <dt>
              "<dfn>accepted</dfn>":
            </dt>
            <dd>
              The end-user indicated that they would like the user agent to
              install the web application.
            </dd>
            <dt>
              "<dfn>dismissed</dfn>":
            </dt>
            <dd>
              The end-user dismissed the install prompt.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>
          Extensions to the `Window` object
        </h3>
        <pre class="idl" data-cite="HTML">
          partial interface Window {
            attribute EventHandler onappinstalled;
            attribute EventHandler onbeforeinstallprompt;
          };
        </pre>
        <section data-dfn-for="Window">
          <h4>
            <code>onappinstalled</code> attribute
          </h4>
          <p>
            The <dfn>onappinstalled</dfn> <a>event handler IDL attribute</a>
            handles "<dfn class="event">appinstalled</dfn>" events.
          </p>
        </section>
        <section data-dfn-for="Window">
          <h4>
            <code>onbeforeinstallprompt</code> attribute
          </h4>
          <p>
            The <dfn>onbeforeinstallprompt</dfn> <a>event handler IDL
            attribute</a> handles "<dfn class=
            "event">beforeinstallprompt</dfn>" events.
          </p>
        </section>
      </section>
    </section>
    <section id="conformance"></section>
  </body>
</html>
